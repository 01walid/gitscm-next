- @section = "about"
- @page_title = "Git - About"

- content_for :sidebar do
  %div.callout
    %p
      The entire <strong><a href="#">Pro Git book</a></strong> written by Scott Chacon is available to <a href="#">read online for free</a>. Dead tree versions are available on <a href="#">Amazon.com</a>.

%div#main
  %h1 About

  %ol#about-nav
    %li
      <a href="#" class="current three-line" id="nav-branching-and-merging" data-section-id="branching-and-merging">Branching and Merging</a>
    %li
      <a href="#" class="two-line" id="nav-small-and-fast" data-section-id="small-and-fast">Small and Fast</a>
    %li
      <a href="#" class="one-line" id="nav-distributed" data-section-id="distributed">Distributed</a>
    %li
      <a href="#" class="two-line" id="nav-info-assurance" data-section-id="info-assurance">Data Assurance</a>
    %li
      <a href="#" class="two-line" id="nav-staging-area" data-section-id="staging-area">Staging Area</a>
    %li
      <a href="#" class="three-line" id="nav-free-and-open-source" data-section-id="free-and-open-source">Free and Open Source</a>

  %section.about#branching-and-merging.current
    %h2 Branching and Merging

    %p
      Probably Git's most compelling feature that really makes it stand
      apart from nearly every other SCM out there is its branching
      model.

    %p
      Git allows and encourages you to have multiple
      local branches that can be entirely independent of each other.
      The creation, merging and deletion of those lines of development
      take seconds.

    %p
      This means that you can do things like:

    %ul.bullets
      %li
        <strong>Frictionless Context Switching</strong>. Create a branch to try out an idea, commit a few times, switch back to where you branched from, apply a patch, switch back to where you are experimenting, then merge it in.
      %li
        <strong>Role-Based Codelines</strong>. Have a branch that always contains only what goes to production, another that you merge work into for testing and several smaller ones for day to day work
      %li
        <strong>Feature Based Workflow</strong>. Create new branches for each new feature you're working on, so you can seamlessly switch back and forth between them, then delete each branch when that feature gets merged into your main line.
      %li
        <strong>Disposable Experimentation</strong>. Create a branch to experiment in, realize it's not going to work and just delete it, abandoning the work—with nobody else ever seeing it (even if you've pushed other branches in the meantime)

    %p.center
      <img src="/images/about/branches.png" alt="Branches" />

    %p
      Importantly, when you push to a remote repository, you do not have to push all of your branches. You can only share one of your branches and not all of them. This tends to free people to try new ideas without worrying about having to plan how and when they are going to merge it in or share it with others.

    %p
      You can find ways to do some of this with other systems, but the work involved is much more difficult and error-prone. Git makes this process incredibly easy and it changes the way most developers work when they learn it.

    %div.bottom-nav
      =link_to "Small and Fast →", "#", {:class => 'next', 'data-section-id' => 'small-and-fast'}


  %section.about#small-and-fast
    %h2 Small and Fast

    %p
      <strong>Git is fast</strong>. With Git, nearly all operations are performed locally giving it a huge speed advantage on centralized systems that constantly have to communicate with a server somewhere.

    %p
      It was also built to work on the Linux kernel, which means that it has had to deal effectively with large repositories from day one. Git is written in C, reducing the overhead of runtimes associated with higher-level languages. Speed and performance has been a primary design goal of the Git from the start.

    %h3 Benchmarks

    %p 
      If you don't believe me, let's see how common operations stack up against
      Subversion, a common centralized version control system that is similar
      to CVS or Perforce. <em>Smaller is faster.</em>

    %table{:width => '100%'}
      %tr
        %td
          =raw gchart("Commit A", [['git', 0.649], ['svn', 2.6]])
        %td
          =raw gchart("Commit B", [['git', 1.53], ['svn', 24.7]])
        %td
          =raw gchart("Diff Curr", [['git', 0.257], ['svn', 1.09]])
        %td
          =raw gchart("Diff Rec", [['git', 0.248], ['svn', 3.99]])
        %td
          =raw gchart("Diff Tags", [['git', 1.17], ['svn', 83.57]])
        %td
          =raw gchart("Clone", [['git*', 21.0], ['git', 107.5], ['svn', 14.0]])
      %tr
        %td
          =raw gchart("Log (50)", [['git', 0.012], ['svn', 0.381]])
        %td
          =raw gchart("Log (All)", [['git', 0.519], ['svn', 169.197]])
        %td
          =raw gchart("Log (File)", [['git', 0.601], ['svn', 82.843]])
        %td
          =raw gchart("Update", [['git', 0.896], ['svn', 2.816]])
        %td
          =raw gchart("Blame", [['git', 1.91], ['svn', 3.04]])
        %td
          =raw gchart("Size", [['git', 181], ['svn', 132]])
    %p 
      To test, I set up large AWS instances in the same availability zone and
      installed Git and SVN on both machines, put the Ruby repository on both
      the SVN and Git servers, then did some common operations on both.
    %p
      In the cases where the commands don't match up exactly, I tried to match
      on the lowest common denominator - for example, for the 'commit' tests I
      am also including time to push for Git, though most of the time you would
      not actually be pushing to the server immediately after a push where you
      cannot seperate the two operations in SVN.
    %p
      All of these times are in seconds.

    %table.benchmarks
      %tr
        %th Operation
        %th
        %th.right Git
        %th.right SVN
      =raw rchart("Commit Files (A)", [['git', 0.64], ['svn', 2.60]], "Add, commit and push 113 modified files (2164+, 2259-)")
      =raw rchart("Commit Images (B)", [['git', 1.53], ['svn', 24.70]], "Add, commit and push 1000 1k images")
      =raw rchart("Diff Current", [['git', 0.25], ['svn', 1.09]], "Diff 187 changed files (1664+, 4859-) against last commit")
      =raw rchart("Diff Recent", [['git', 0.248], ['svn', 3.99]], "Diff against 4 commits back (269 changed/3609+,6898-)")
      =raw rchart("Diff Tags", [['git', 1.17], ['svn', 83.57]], "Diff two tags against each other (v1.9.1.0/v1.9.3.0 )")
      =raw rchart("Log (50)", [['git', 0.012], ['svn', 0.381]], "Log of the last 50 commits (19k of output)")
      =raw rchart("Log (All)", [['git', 0.52], ['svn', 169.20]], "Log of all commits (26,056 commits - 9.4M of output)")
      =raw rchart("Log (File)", [['git', 0.60], ['svn', 82.84]], "Log of the history of a single file (array.c - 483 revs)")
      =raw rchart("Update", [['git', 0.90], ['svn', 2.82]], "Pull of Commit A scenario (113 files changed, 2164+, 2259-)")
      =raw rchart("Blame", [['git', 1.91], ['svn', 3.04]], "Line annotation of a single file (array.c)")

    %p
      This is basically the best case scenario for SVN - a server with no load with an
      80MB/s bandwidth connection to the client machine.  Nearly all of these
      times would be even worse for SVN if that connection was slower, while
      many of the Git times would not be affected.
    %p
      As you can see, in many of these common version control operations, <strong>Git is
      one or two orders of magnitude faster than SVN</strong>, even under ideal conditions
      for SVN.

    %p
      A couple of places that Git is slower or bigger is in the initial clone operation
      since Git is downloading the entire history rather than only the latest
      version. However, as you can see, it's not hugely slower for an operation
      that you only ever do once.

    %table.benchmarks
      %tr
        %th Operation
        %th
        %th.right Git*
        %th.right Git
        %th.right SVN
      =raw trchart("Clone", [['git*', 21.0], ['git', 107.50], ['svn', 14.00]], "Clone and shallow clone(*) in Git vs checkout in SVN")
      =raw trchart("Size (M)", [[nil, nil], ['git', 181], ['svn', 132]], "Size of total client side data and files after clone/checkout (in M)")

    %p
      It's also interesting to point out the size of the data on the client side
      is very similar even though Git also has every version of every file for the
      entire history of the project - this is how efficient it is at compressing
      and storing data on the client side.


    %div.bottom-nav
      =link_to "← Branching and Merging", "#", {:class => 'previous', 'data-section-id' => 'branching-and-merging'}
      =link_to "Distributed →", "#", {:class => 'next', 'data-section-id' => 'distributed'}

  %section.about#distributed
    %h2 Distributed

    %p
      One of the coolest features of any of the Distributed SCMs, Git included, is that it's distributed. This means that instead of doing a "checkout" of the current tip of the source code, you do a "clone" of the entire repository.

    %h3 Multiple Backups

    %p
      This means that even if you're using a centralized workflow, every user has what is essentially a full backup of the main server, each of which could be pushed up to replace the main server in the event of a crash or corruption. There is basically no single point of failure with Git unless there is only a single point.

    %h3 Any Workflow

    %p
      One of the amazing things about Git is that because of its distributed nature and super branching system, you can easily implement pretty much any workflow you can think of relatively easily.

    %h4 Subversion-Style Workflow

    %p
      A very common Git workflow, especially from people transitioning from a centralized system, is a centralized workflow. Git will not allow you to push if someone has pushed since the last time you fetched, so a centralized model where all developers push to the same server works just fine.

    %p.center
      <img src="/images/about/workflow-a.png" alt="Workflow A" />

    %h4 Integration Manager Workflow

    %p
      Another common Git workflow is where there is an integration manager—a single person who commits to the 'blessed' repository, and then a number of developers who clone from that repository, push to their own independent repositories and ask the integrator to pull in their changes. This is the type of development model you often see with open source or GitHub repositories.

    %p.center
      <img src="/images/about/workflow-b.png" alt="Workflow B" />

    %h4 Dictator and Lieutenants Workflow

    %p
      For more massive projects, you can setup your developers similar to the way the Linux kernel is run, where people are in charge of a specific subsystem of the project ('lieutenants') and merge in all changes that have to do with that subsystem. Then another integrator (the 'dictator') can pull changes from only his/her lieutenants and the push to the 'blessed' repository that everyone then clones from again.

    %p.center
      <img src="/images/about/workflow-c.png" alt="Workflow C" />

    %div.bottom-nav
      =link_to "← Small and Fast", "#", {:class => 'previous', 'data-section-id' => 'small-and-fast'}
      =link_to "Data Assurance →", "#", {:class => 'next', 'data-section-id' => 'info-assurance'}

  %section.about#info-assurance
    %h2 Data Assurance

    %p
      The data model that Git uses ensures cryptographic integrity of every bit
      of your project.  Every file and commit is checksummed and retrieved by it's
      checksum when checked back out. It's impossible to get out of Git anything
      other than the <strong>exact bits you put in</strong>.

    %img{:src => "/images/assurance.png"}

    %p
      It is also impossible to change any file, date, commit message or any other
      data in a Git repository without changing the IDs of everything after it.
      This means that if you have a commit ID you can not only be assured that
      your project is exactly the same as when it was committed, but you can also
      be assured that nothing in it's history was changed.

    %p
      Most centralized version control systems provide no such integrity by default.

    %div.bottom-nav
      =link_to "← Distributed", "#", {:class => 'previous', 'data-section-id' => 'distributed'}
      =link_to "Staging Area →", "#", {:class => 'next', 'data-section-id' => 'staging-area'}

  %section.about#staging-area
    %h2 Staging Area

    %p
      Unlike the other systems, Git has what it calls the "staging area" or "index". This is an intermediate area that you can setup what you want your commit to look like before you commit it.

    %p
      The cool thing about the staging area, and what sets Git apart from all these other tools, is that you can easily stage some of your files as you finish them and then commit them without committing all the modified files in your working directory, or having to list them on the command line during the commit

    %p.center
      <img src="/images/about/index1.png" alt="Index 1" />

    %p
      This also allows you to stage only portions of a modified file. Gone are the days of making two logically unrelated modifications to a file before you realized that you forgot to commit one them. Now you can just stage the change you need for the current commit and stage the other change for the next commit. This feature scales up to as many different changes to your file as you need.

    %p
      Of course, Git also makes it pretty easy to ignore this feature if you don't want that kind of control—just slap a '-a' to your commit command in order to add all changes to all files to the staging area.

    %p.center
      <img src="/images/about/index2.png" alt="Index 2" />

    %div.bottom-nav
      =link_to "← Data Assurance", "#", {:class => 'previous', 'data-section-id' => 'info-assurance'}
      =link_to "Free and Open Source →", "#", {:class => 'next', 'data-section-id' => 'free-and-open-source'}


  %section.about#free-and-open-source
    %h2 Free and Open Source

    %p
      Git is released under the <a href="https://github.com/git/git/blob/master/COPYING">GPLv2</a> <a href="http://www.opensource.org/docs/osd">open source license</a>.  This means that you are free to <a href="https://github.com/git/git">inspect the source code</a> at any time or <a href="https://github.com/git/git/blob/master/Documentation/SubmittingPatches">contribute</a> to the project yourself.

    %p
      Under Git's GPLv2 software license, you <strong>may</strong>:

      %ul.bullets
        %li Use Git on open or proprietary projects for free, forever
        %li Download, inspect and modify the source code to Git
        %li Make proprietary changes to Git that you do not redistribute publicly
        %li Call Git binaries from your open or proprietary programs
        %li Publicly redistribute Git binaries with open or proprietary programs, given that they are unmodified or the modifications are public

    %p
      Under this license you <strong>may not</strong>:

      %ul.bullets
        %li Make proprietary changes to Git and publicly redistribute it without sharing the changes
        %li Make and publicly distribute changes to Git under a different license
        %li Use source code from the Git repository in a different project without permission

    %div.bottom-nav
      =link_to "← Staging Area", "#", {:class => 'previous', 'data-section-id' => 'staging-area'}
